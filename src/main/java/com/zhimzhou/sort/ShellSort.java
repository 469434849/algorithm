package main.java.com.zhimzhou.sort;

/**
 * 希尔排序 不稳定 O（n^2）
 * 插入排序的一种，将数据分组排序，各分组进行插入排序，一次降低增量至增量为1
 * <p>
 * Hibbard增量的希尔排序的时间复杂度为O(N3/2)。
 * 对于Hibbard增量来说，其增量序列为{1,3,7……hn−1,hn}，并且hi+1=2hi+1。  2^1-1  2^2-1 ....2^n-1
 * 总趟数：log2(n+1)
 * 如：排序个数为10个  log2(n+1)=3 第一趟增量为：(2^(3-1+1))-1=7   第二趟:(2^(3-2+1))-1=3 第三趟：(2^(3-3+1))-1=1
 *
 * @author main.java.zhimzhou
 * @date 2018/12/29 10:26
 **/

/**
 * hibbard 增量
 * <p>
 * 排序总趟数：floor(log2(n+1)) n为元素个数
 * 增量计数方式：int(pow(2,tanshu-dijitang+1)-1)  tanshu：排序的总趟数 dijitang:当前进行排序的为第几趟
 */

public class ShellSort {
	public static void main(String[] args) {
		int[] array = new int[]{
				10, 18, 4, 3, 6, 12, 1, 9, 15, 8
		};
		//shellSort(array, array.length);
		shellSortByHibbard(array, array.length);
	}

	/**
	 * 常规增量 n n/2  n/2/2....1
	 */
	private static void shellSort(int[] array, int length) {
		int gap, i, j;
		for (gap = length / 2; gap > 0; gap /= 2) {
			for (i = 0; i < gap; i++) {
				//每组进行直接插入排序
				for (j = i + gap; j < length; j += gap) {
					int tmp = array[j];
					int k = j - gap;
					while (k >= 0 && array[k] > tmp) {
						array[k + gap] = array[k];
						k -= gap;
					}
					array[k + gap] = tmp;
					PrintUtil.printArray(array);
				}
			}
			System.out.println(gap);
		}
	}

	private static void shellSortByHibbard(int[] array, int length) {
		int allNum = (int) (Math.log(length + 1) / Math.log(2));
		System.out.println("需要排序的趟数:" + allNum);
		int gap, i, j;
		int count = 1;
		while (count <= allNum) {
			gap = getHibbardValue(allNum, count);
			System.out.println("当前为第:" + count + "趟排序,增量为:" + gap);
			for (i = 0; i < gap; i++) {
				//每组进行直接插入排序
				for (j = i + gap; j < length; j += gap) {
					int temp = array[j];
					int before = j - gap;
					while (before >= 0 && array[before] > temp) {
						array[before + gap] = array[before];
						before -= gap;
					}
					array[before + gap] = temp;
					PrintUtil.printArray(array);
				}
			}
			count++;
		}
	}

	/**
	 * hibbard 增量
	 * <p>
	 * 排序总趟数：floor(log2(n+1)) 为元素个数
	 * 增量计数方式：int(pow(2,tanshu-dijitang+1)-1)  tanshu：排序的总趟数 dijitang:当前进行排序的为第几趟
	 */
	public static int getHibbardValue(int allNum, int currentNum) {
		return (int) (Math.pow(2, allNum - currentNum + 1) - 1);
	}
}

/**
 * 按着常规增量一次将每组数据进行直接插入排序
 * <p>
 * 10	18	4	3	6	12	1	9	15	8
 * 10	1	4	3	6	12	18	9	15	8
 * 10	1	4	3	6	12	18	9	15	8
 * 10	1	4	3	6	12	18	9	15	8
 * 10	1	4	3	6	12	18	9	15	8
 * 5
 * 4	1	10	3	6	12	18	9	15	8
 * 4	1	6	3	10	12	18	9	15	8
 * 4	1	6	3	10	12	18	9	15	8
 * 4	1	6	3	10	12	15	9	18	8
 * 4	1	6	3	10	12	15	9	18	8
 * 4	1	6	3	10	12	15	9	18	8
 * 4	1	6	3	10	9	15	12	18	8
 * 4	1	6	3	10	8	15	9	18	12
 * 2
 * 1	4	6	3	10	8	15	9	18	12
 * 1	4	6	3	10	8	15	9	18	12
 * 1	3	4	6	10	8	15	9	18	12
 * 1	3	4	6	10	8	15	9	18	12
 * 1	3	4	6	8	10	15	9	18	12
 * 1	3	4	6	8	10	15	9	18	12
 * 1	3	4	6	8	9	10	15	18	12
 * 1	3	4	6	8	9	10	15	18	12
 * 1	3	4	6	8	9	10	12	15	18
 * 1
 * <p>
 * hibbard增量排序
 * 需要排序的趟数:3
 * 当前为第:1趟排序,增量为:7
 * 9	18	4	3	6	12	1	10	15	8
 * 9	15	4	3	6	12	1	10	18	8
 * 9	15	4	3	6	12	1	10	18	8
 * 当前为第:2趟排序,增量为:3
 * 3	15	4	9	6	12	1	10	18	8
 * 1	15	4	3	6	12	9	10	18	8
 * 1	15	4	3	6	12	8	10	18	9
 * 1	6	4	3	15	12	8	10	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 当前为第:3趟排序,增量为:1
 * 1	6	4	3	10	12	8	15	18	9
 * 1	4	6	3	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	9	10	12	15	18
 * <p>
 * hibbard增量排序
 * 需要排序的趟数:3
 * 当前为第:1趟排序,增量为:7
 * 9	18	4	3	6	12	1	10	15	8
 * 9	15	4	3	6	12	1	10	18	8
 * 9	15	4	3	6	12	1	10	18	8
 * 当前为第:2趟排序,增量为:3
 * 3	15	4	9	6	12	1	10	18	8
 * 1	15	4	3	6	12	9	10	18	8
 * 1	15	4	3	6	12	8	10	18	9
 * 1	6	4	3	15	12	8	10	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 当前为第:3趟排序,增量为:1
 * 1	6	4	3	10	12	8	15	18	9
 * 1	4	6	3	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	9	10	12	15	18
 * <p>
 * hibbard增量排序
 * 需要排序的趟数:3
 * 当前为第:1趟排序,增量为:7
 * 9	18	4	3	6	12	1	10	15	8
 * 9	15	4	3	6	12	1	10	18	8
 * 9	15	4	3	6	12	1	10	18	8
 * 当前为第:2趟排序,增量为:3
 * 3	15	4	9	6	12	1	10	18	8
 * 1	15	4	3	6	12	9	10	18	8
 * 1	15	4	3	6	12	8	10	18	9
 * 1	6	4	3	15	12	8	10	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 当前为第:3趟排序,增量为:1
 * 1	6	4	3	10	12	8	15	18	9
 * 1	4	6	3	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	9	10	12	15	18
 */

/**
 * hibbard增量排序
 * 需要排序的趟数:3
 * 当前为第:1趟排序,增量为:7
 * 9	18	4	3	6	12	1	10	15	8
 * 9	15	4	3	6	12	1	10	18	8
 * 9	15	4	3	6	12	1	10	18	8
 * 当前为第:2趟排序,增量为:3
 * 3	15	4	9	6	12	1	10	18	8
 * 1	15	4	3	6	12	9	10	18	8
 * 1	15	4	3	6	12	8	10	18	9
 * 1	6	4	3	15	12	8	10	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 1	6	4	3	10	12	8	15	18	9
 * 当前为第:3趟排序,增量为:1
 * 1	6	4	3	10	12	8	15	18	9
 * 1	4	6	3	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	10	12	8	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	10	12	15	18	9
 * 1	3	4	6	8	9	10	12	15	18
 */


